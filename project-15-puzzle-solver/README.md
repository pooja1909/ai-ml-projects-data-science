#15 Puzzle Solver

###15 puzzle Problem Abstraction:

• Initial State: A random/user input state with 15 tiles on the board, each occupying exactly one place
on the board. No duplicates are allowed. The board may often times be unsolvable.  

• Goal State: Tiles arranged in the correct order from 1 to 15 and the blank space at the end after the
15th tile, wherein one tile exactly occupies one place.  

• Valid State: Any state generated by the successor() is valid, where each tiles occupies exactly one
place.  

• State State: State Space is the collection of all the states that have been discovered but not visited,
they are stored in a fringe, which constantly pops the state with the lowest cost (i.e. the sum of g(s) +
f(s)).  

• Successor Functions: Through each state there are 4 possible states, wherein the tile can slide D,
U, R, L into the empty place. Technically only 3 would be good to use depending upon the previous
state, otherwise you would be replicating the parent state by moving back in the same position. Eg:
If your parent is L, then moving in the Right direction would lead you back to the same state, hence
we can eliminate that.  

• Cost Functions: Cost Function is the cost of travelling from one state to another which is 1 for
each movement. Also we use a heuristic to estimate the length of the goal which helps us get to the
solution quicker than the brute force way.  

Implementation Details: Try to make your solver as fast as possible. Which heuristic functions did you
try, and which works best?  

• We tried three different heuristics:  

– Hamming Distance: This heuristic calculates the number of misplaced tiles. In other words,
all it does is that it checks whether if a tile is in its location, if not adds 1 to the cost. This is
not a particularly good estimate of how far are we from the solution. The idea of a heuristic is to
estimate the distance from the goal which in turn allows us to select a good probable path. Even
though this is admissible since it does not overestimate the cost, it duly underestimates it most
of the times.  

– Permutation Inversion: This heuristic particularly checks for inversion, which means it checks
how many pairs are out of order. This is often times not admissible and hence can be discarded,
since heuristic functions do not allow us to overestimate the distance to the goal.  

– Manhattan Distance: This heuristic calculates the steps for each tile to reach its correct
position when no other tiles is on the table. This is the best of the three, since it does not over
estimate (admissible) but also gives us a fair amount of idea as to how far are we from the solution.
Manhattan distance is also consistent because it generates a heuristic better than the current state for, 
its neighbours. Also, the cases for edge movements have been handled for the flip tile moves otherwise
it would have been over estimated because we can travel 3 moves in the x direction, but with the flip tile
movement if at all you have to travel 3 steps, you could always do it one step and the same goes for y.  

• We implemented A* search algorithm to find the optimal path to the solution, code would be present
in the problem2 folder. We have used tuples to enhance efficiency and also because it can be easily 
hashed which in turn reduces the access times to check visited states and storing the elements in the fringe set.  

Algorithm:
```
if (current_state is goal_state) return initial state
fringe.add (initial_state)
Repeat until fringe is empty:
	fringe.pop() <- current
	visited.add (current)
	if current == goal: return path
	for each_successor in successor_list(s):
		if successor in visited: ignore
		calc_heuristic()
		if successor in fringe: old_successor = fringe.pop()
			compare successors and insert smaller one
		if not in fringe, insert.
```

• Tests carried for professors input, we obtain a path of 24 steps (LLUURULULDRDRDRRULDRUUUL)
within about 2 seconds (0:00:02.189130) on our local machines. There are various test cases we tried,
some take a while and some happen quickly, it fairly depends upon the complexity of the input.  